# Product Requirements Document (PRD)

## User Authentication & Personalization

**Version:** 1.0  
**Date:** 2025-12-28  
**Status:** Draft

---

## Overview

Implement user authentication and personalization features to enable users to sign in, configure their preferences, and customize their experience. This includes email-based authentication (magic link or token), user-specific settings for sports, spots, display preferences, custom scoring prompts, and the ability to request new spots.

---

## Goals

1. **Simple Email Authentication**: Implement passwordless authentication using email magic links or tokens
2. **User Preferences**: Allow users to configure their sports, favorite spots, and app settings
3. **Personalized Scoring**: Enable users to create custom prompts for sport and spot-sport condition evaluation
4. **Spot Requests**: Allow users to request new spots to be added to the platform
5. **Seamless Experience**: Maintain existing anonymous functionality while adding authenticated features

---

## Current State Analysis

### Existing System

**Current Behavior**:

- Application is fully anonymous (no user accounts)
- Preferences stored in localStorage (sports selection, filter preferences)
- All scoring uses system/default prompts
- No user-specific data or personalization

**Limitations**:

- Preferences lost when clearing browser data
- No cross-device synchronization
- Cannot customize scoring criteria per user
- Cannot request new spots
- No user-specific settings (theme, display preferences)

---

## Requirements

### 1. Authentication System

#### 1.1 Email-Based Authentication

**Method**: Passwordless authentication using email magic links or tokens

**Flow**:

1. **Sign In Request**:
   - User enters email address
   - System generates authentication token (cryptographically secure, time-limited)
   - Token stored in database with expiration (e.g., 15 minutes)
   - Email sent with magic link containing token

2. **Email Magic Link**:
   - Link format: `https://app.waterman.com/auth/verify?token={token}&email={email}`
   - Token is single-use and expires after 15 minutes
   - Clicking link verifies token and signs user in

3. **Alternative: Email Token**:
   - User enters email address
   - System sends email with 6-digit numeric code
   - User enters code to verify and sign in
   - Code expires after 15 minutes

**Decision**: Support both methods (magic link as primary, token code as fallback)

#### 1.2 Session Management

**Session Storage**:

- JWT token or session ID stored in secure HTTP-only cookie
- Session expires after 30 days of inactivity
- User can sign out (clears session)

**User Identification**:

- Each user has unique `userId` (UUID or Convex ID)
- Email address is primary identifier
- Email addresses are unique (one account per email)

#### 1.3 Authentication States

**States**:

- **Anonymous**: No authentication (current default behavior)
- **Authenticated**: User signed in with valid session
- **Session Expired**: Session expired, prompt to sign in again

**Anonymous Mode**:

- Users can continue using app without signing in
- Preferences stored in localStorage (as currently)
- No access to personalized features

---

### 2. User Preferences & Settings

#### 2.1 Sports Configuration

**Feature**: Users can configure which sports they practice

**Storage**:

- Stored in `userPreferences` table
- Array of sport names: `["wingfoil", "surfing"]`
- Default: All sports (matches current behavior)

**UI**:

- Settings page with sport selection checkboxes
- Can be updated from main sport selector (if authenticated)
- Changes sync across devices

**Behavior**:

- When authenticated, use user's preferred sports as default
- Can still temporarily select different sports (stored in session, not persisted)
- Preference persists across sessions

#### 2.2 Favorite Spots

**Feature**: Users can mark spots as favorites for quick access

**Storage**:

- New table: `userFavoriteSpots`
- Fields: `userId`, `spotId`, `order` (optional, for custom ordering)
- Index on `["userId", "spotId"]` for efficient lookups

**UI**:

- Star/heart icon on spot cards to mark as favorite
- Favorites section in settings
- Can reorder favorites (optional)
- Filter to show only favorites (optional)

**Behavior**:

- Favorites appear at top of spot list (or in separate section)
- Can filter forecast view to show only favorite spots
- Preference syncs across devices

#### 2.3 Display Preferences

**Feature**: Users can configure how condition data is displayed

**Settings**:

- **Condition Display Format**:
  - "Detailed" (current format with all metrics)
  - "Compact" (condensed view)
  - "Minimal" (key metrics only)
- **Theme**:
  - "Light" (current)
  - "Dark" (future)
  - "Auto" (system preference)
- **Time Format**:
  - "12-hour" (e.g., "2:00 PM")
  - "24-hour" (e.g., "14:00")
- **Date Format**:
  - "MM/DD/YYYY"
  - "DD/MM/YYYY"
  - "YYYY-MM-DD"
- **Units**:
  - Wind speed: "knots" (default) or "m/s" or "mph"
  - Wave height: "meters" (default) or "feet"
  - Temperature: "Celsius" or "Fahrenheit"

**Storage**:

- Stored in `userPreferences` table
- JSON object with all display settings
- Defaults match current app behavior

**UI**:

- Settings page with all display options
- Changes apply immediately
- Preference syncs across devices

#### 2.4 Other App Settings

**Future Settings** (can be added incrementally):

- **Notifications**: Enable/disable condition alerts
- **Default Filter**: "best" or "all" (currently stored in localStorage)
- **Language**: Multi-language support (future)
- **Data Refresh Rate**: How often to refresh forecast data

**Storage**:

- All settings stored in `userPreferences` table
- Flexible JSON structure allows adding new settings without schema changes

---

### 3. Custom Scoring Prompts

#### 3.1 Sport-Specific Prompts

**Feature**: Users can create custom prompts for evaluating conditions for a specific sport

**Use Cases**:

- "I prefer lighter wind conditions" (lower minimum wind speed)
- "I'm a beginner, score easier conditions higher"
- "I prefer consistent wind over strong gusts"

**Storage**:

- Extend existing `scoring_prompts` table (from PRD 02)
- Add `userId` field (already planned as optional)
- When `userId` is set, it's a user-specific prompt
- When `userId` is null, it's the system/default prompt

**Prompt Structure**:

- Same structure as system prompts:
  - `systemPrompt`: Sport evaluation guidelines
  - `spotPrompt`: Spot-specific characteristics (optional for sport-level prompts)
  - `temporalPrompt`: Temporal context instructions

**UI**:

- Settings → "Custom Prompts" section
- Create/edit prompts for each sport
- Preview prompt before saving
- Test prompt on sample conditions (future)

**Behavior**:

- When scoring: Check for user prompt first, fall back to system prompt
- User prompts override system prompts for that user
- Can reset to system prompt (delete user prompt)

#### 3.2 Spot-Sport-Specific Prompts

**Feature**: Users can create custom prompts for evaluating conditions for a specific spot-sport combination

**Use Cases**:

- "This spot works better with S winds for me" (spot-specific)
- "I prefer this spot at high tide" (tide preference)
- "I need stronger wind at this spot" (spot-specific threshold)

**Storage**:

- Same `scoring_prompts` table
- Requires both `spotId` and `sport` fields
- `userId` identifies it as user-specific

**UI**:

- From spot detail page or settings
- Create/edit prompt for specific spot-sport combination
- Can have different prompts for different spots

**Behavior**:

- Most specific prompt wins:
  1. User spot-sport prompt (most specific)
  2. User sport prompt (less specific)
  3. System spot-sport prompt (default)
  4. System sport prompt (fallback)

---

### 4. Spot Requests

#### 4.1 Request New Spot

**Feature**: Users can request new spots to be added to the platform

**Request Information**:

- **Spot Name**: Name of the spot
- **Location**: Country, region, or coordinates
- **Windy.app URL**: Link to spot on Windy.app (if available)
- **Sports**: Which sports this spot supports
- **Notes**: Additional information (optional)
- **User Email**: Automatically filled from authenticated user

**Storage**:

- New table: `spotRequests`
- Fields:
  - `userId`: User who made the request
  - `spotName`: Name of requested spot
  - `location`: Location information
  - `windyUrl`: Optional Windy.app URL
  - `sports`: Array of sports (e.g., `["wingfoil", "surfing"]`)
  - `notes`: Optional additional notes
  - `status`: "pending", "approved", "rejected", "added"
  - `createdAt`: Timestamp
  - `processedAt`: Optional timestamp when processed
  - `processedBy`: Optional admin user ID

**UI**:

- "Request Spot" button in header or settings
- Form with all required fields
- Confirmation message after submission
- View status of submitted requests (in settings)

**Admin**:

- Admin interface to review requests (future PRD)
- Can approve/reject requests
- When approved, admin can add spot using existing `addSpot` mutation

**Behavior**:

- Requests are queued for admin review
- User receives email confirmation when request is submitted
- User receives email when request is processed (approved/rejected/added)

---

## Database Schema Changes

### New Tables

#### 1. `users` Table

```typescript
users: defineTable({
  email: v.string(), // Unique email address
  emailVerified: v.boolean(), // Whether email is verified
  createdAt: v.number(), // Account creation timestamp
  lastLoginAt: v.optional(v.number()), // Last login timestamp
  isActive: v.boolean(), // Account active status
}).index("by_email", ["email"]);
```

**Design Decisions**:

- Email is unique identifier (no username needed)
- `emailVerified` tracks verification status
- `isActive` allows soft-deleting accounts

#### 2. `authTokens` Table

```typescript
authTokens: defineTable({
  userId: v.id("users"),
  token: v.string(), // Cryptographically secure token
  tokenType: v.string(), // "magic_link" or "email_code"
  email: v.string(), // Email address (denormalized for lookup)
  expiresAt: v.number(), // Expiration timestamp
  usedAt: v.optional(v.number()), // When token was used (single-use)
  createdAt: v.number(), // Token creation timestamp
})
  .index("by_token", ["token"])
  .index("by_email", ["email"])
  .index("by_user", ["userId"]);
```

**Design Decisions**:

- Tokens are single-use (tracked by `usedAt`)
- Expiration enforced via `expiresAt`
- Index on `token` for fast verification lookups

#### 3. `userSessions` Table

```typescript
userSessions: defineTable({
  userId: v.id("users"),
  sessionToken: v.string(), // Session identifier
  expiresAt: v.number(), // Session expiration timestamp
  createdAt: v.number(), // Session creation timestamp
  lastActivityAt: v.number(), // Last activity timestamp (for auto-expiry)
  userAgent: v.optional(v.string()), // Browser/device info
  ipAddress: v.optional(v.string()), // IP address (for security)
})
  .index("by_session_token", ["sessionToken"])
  .index("by_user", ["userId"])
  .index("by_expires_at", ["expiresAt"]); // For cleanup jobs
```

**Design Decisions**:

- Sessions expire after inactivity (30 days)
- Track last activity for auto-expiry
- Store user agent and IP for security monitoring

#### 4. `userPreferences` Table

```typescript
userPreferences: defineTable({
  userId: v.id("users"),
  // Sports configuration
  preferredSports: v.optional(v.array(v.string())), // e.g., ["wingfoil", "surfing"]
  // Display preferences
  displayFormat: v.optional(v.string()), // "detailed" | "compact" | "minimal"
  theme: v.optional(v.string()), // "light" | "dark" | "auto"
  timeFormat: v.optional(v.string()), // "12-hour" | "24-hour"
  dateFormat: v.optional(v.string()), // "MM/DD/YYYY" | "DD/MM/YYYY" | "YYYY-MM-DD"
  windSpeedUnit: v.optional(v.string()), // "knots" | "m/s" | "mph"
  waveHeightUnit: v.optional(v.string()), // "meters" | "feet"
  temperatureUnit: v.optional(v.string()), // "celsius" | "fahrenheit"
  // Other settings
  defaultFilter: v.optional(v.string()), // "best" | "all"
  // Future settings can be added as optional fields
  updatedAt: v.number(), // Last update timestamp
}).index("by_user", ["userId"]);
```

**Design Decisions**:

- Single row per user (can use upsert pattern)
- All preferences in one table for efficient loading
- Optional fields allow gradual feature rollout

#### 5. `userFavoriteSpots` Table

```typescript
userFavoriteSpots: defineTable({
  userId: v.id("users"),
  spotId: v.id("spots"),
  order: v.optional(v.number()), // Custom ordering (lower = higher priority)
  createdAt: v.number(), // When added as favorite
})
  .index("by_user", ["userId"])
  .index("by_user_spot", ["userId", "spotId"]);
```

**Design Decisions**:

- `order` field allows custom sorting of favorites
- Index on `["userId", "spotId"]` prevents duplicates and enables fast lookups

#### 6. `spotRequests` Table

```typescript
spotRequests: defineTable({
  userId: v.id("users"),
  spotName: v.string(),
  location: v.string(), // Country, region, or coordinates
  windyUrl: v.optional(v.string()), // Windy.app URL
  sports: v.array(v.string()), // e.g., ["wingfoil", "surfing"]
  notes: v.optional(v.string()), // Additional information
  status: v.string(), // "pending" | "approved" | "rejected" | "added"
  createdAt: v.number(),
  processedAt: v.optional(v.number()),
  processedBy: v.optional(v.id("users")), // Admin user ID
  adminNotes: v.optional(v.string()), // Admin notes (internal)
})
  .index("by_user", ["userId"])
  .index("by_status", ["status"])
  .index("by_created_at", ["createdAt"]);
```

**Design Decisions**:

- Status tracking enables workflow management
- Index on `status` for admin queries (pending requests)
- `processedBy` tracks which admin handled the request

### Updated Tables

#### 1. `scoring_prompts` Table (from PRD 02)

**Add Field**:

- `userId: v.optional(v.id("users"))` - Already planned in PRD 02

**Behavior**:

- When `userId` is null: System/default prompt
- When `userId` is set: User-specific prompt
- Index on `["userId", "spotId", "sport"]` for efficient lookups

---

## Implementation Details

### 1. Authentication Flow

#### 1.1 Sign In Request

**Convex Action**: `auth.requestSignIn`

```typescript
export const requestSignIn = action({
  args: {
    email: v.string(),
    method: v.optional(
      v.union(v.literal("magic_link"), v.literal("email_code"))
    ),
  },
  handler: async (ctx, args) => {
    // 1. Validate email format
    // 2. Generate secure token
    // 3. Create or get user record
    // 4. Store token in authTokens table
    // 5. Send email with magic link or code
    // 6. Return success
  },
});
```

**Email Service**:

- Use email service (e.g., SendGrid, Resend, or Convex email integration)
- Template for magic link email
- Template for code email
- Include expiration time in email

#### 1.2 Verify Token

**Convex Action**: `auth.verifyToken`

```typescript
export const verifyToken = action({
  args: {
    token: v.string(),
    email: v.string(),
  },
  handler: async (ctx, args) => {
    // 1. Look up token in authTokens table
    // 2. Verify token is valid (not used, not expired)
    // 3. Verify email matches
    // 4. Mark token as used
    // 5. Create session
    // 6. Return session token
  },
});
```

#### 1.3 Create Session

**Convex Mutation**: `auth.createSession`

```typescript
export const createSession = mutation({
  args: {
    userId: v.id("users"),
    userAgent: v.optional(v.string()),
    ipAddress: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // 1. Generate session token
    // 2. Calculate expiration (30 days from now)
    // 3. Create session record
    // 4. Return session token
  },
});
```

#### 1.4 Verify Session

**Convex Query**: `auth.getCurrentUser`

```typescript
export const getCurrentUser = query({
  args: {
    sessionToken: v.string(),
  },
  handler: async (ctx, args) => {
    // 1. Look up session
    // 2. Verify session is valid (not expired)
    // 3. Update lastActivityAt
    // 4. Return user object
  },
});
```

#### 1.5 Sign Out

**Convex Mutation**: `auth.signOut`

```typescript
export const signOut = mutation({
  args: {
    sessionToken: v.string(),
  },
  handler: async (ctx, args) => {
    // 1. Delete session record
    // 2. Return success
  },
});
```

### 2. User Preferences

#### 2.1 Get User Preferences

**Convex Query**: `users.getPreferences`

```typescript
export const getPreferences = query({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    // 1. Get user preferences from userPreferences table
    // 2. Return preferences object (with defaults if not set)
  },
});
```

#### 2.2 Update User Preferences

**Convex Mutation**: `users.updatePreferences`

```typescript
export const updatePreferences = mutation({
  args: {
    userId: v.id("users"),
    preferences: v.object({
      preferredSports: v.optional(v.array(v.string())),
      displayFormat: v.optional(v.string()),
      theme: v.optional(v.string()),
      // ... other optional fields
    }),
  },
  handler: async (ctx, args) => {
    // 1. Upsert user preferences
    // 2. Update updatedAt timestamp
    // 3. Return success
  },
});
```

### 3. Favorite Spots

#### 3.1 Get Favorite Spots

**Convex Query**: `users.getFavoriteSpots`

```typescript
export const getFavoriteSpots = query({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    // 1. Query userFavoriteSpots table
    // 2. Sort by order field
    // 3. Return array of spot IDs
  },
});
```

#### 3.2 Add Favorite Spot

**Convex Mutation**: `users.addFavoriteSpot`

```typescript
export const addFavoriteSpot = mutation({
  args: {
    userId: v.id("users"),
    spotId: v.id("spots"),
  },
  handler: async (ctx, args) => {
    // 1. Check if already favorite (prevent duplicates)
    // 2. Get current max order
    // 3. Create favorite record with order = max + 1
    // 4. Return success
  },
});
```

#### 3.3 Remove Favorite Spot

**Convex Mutation**: `users.removeFavoriteSpot`

```typescript
export const removeFavoriteSpot = mutation({
  args: {
    userId: v.id("users"),
    spotId: v.id("spots"),
  },
  handler: async (ctx, args) => {
    // 1. Delete favorite record
    // 2. Return success
  },
});
```

### 4. Custom Prompts

#### 4.1 Get User Prompt

**Convex Query**: `prompts.getUserPrompt`

```typescript
export const getUserPrompt = query({
  args: {
    userId: v.id("users"),
    sport: v.string(),
    spotId: v.optional(v.id("spots")),
  },
  handler: async (ctx, args) => {
    // 1. If spotId provided: Check for user spot-sport prompt first
    // 2. Fall back to user sport prompt
    // 3. Fall back to system spot-sport prompt
    // 4. Fall back to system sport prompt
    // 5. Return most specific prompt found
  },
});
```

#### 4.2 Save User Prompt

**Convex Mutation**: `prompts.saveUserPrompt`

```typescript
export const saveUserPrompt = mutation({
  args: {
    userId: v.id("users"),
    sport: v.string(),
    spotId: v.optional(v.id("spots")),
    systemPrompt: v.string(),
    spotPrompt: v.optional(v.string()),
    temporalPrompt: v.string(),
  },
  handler: async (ctx, args) => {
    // 1. Upsert prompt in scoring_prompts table
    // 2. Set userId field
    // 3. Return success
  },
});
```

#### 4.3 Delete User Prompt

**Convex Mutation**: `prompts.deleteUserPrompt`

```typescript
export const deleteUserPrompt = mutation({
  args: {
    userId: v.id("users"),
    sport: v.string(),
    spotId: v.optional(v.id("spots")),
  },
  handler: async (ctx, args) => {
    // 1. Delete user prompt record
    // 2. User will fall back to system prompt
    // 3. Return success
  },
});
```

### 5. Spot Requests

#### 5.1 Create Spot Request

**Convex Mutation**: `spots.requestSpot`

```typescript
export const requestSpot = mutation({
  args: {
    userId: v.id("users"),
    spotName: v.string(),
    location: v.string(),
    windyUrl: v.optional(v.string()),
    sports: v.array(v.string()),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // 1. Create spot request record
    // 2. Set status to "pending"
    // 3. Send email confirmation to user
    // 4. Send notification to admin (future)
    // 5. Return request ID
  },
});
```

#### 5.2 Get User Spot Requests

**Convex Query**: `spots.getUserSpotRequests`

```typescript
export const getUserSpotRequests = query({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    // 1. Query spotRequests table by userId
    // 2. Sort by createdAt (newest first)
    // 3. Return array of requests
  },
});
```

---

## Frontend Implementation

### 1. Authentication UI

#### 1.1 Sign In Modal/Page

**Components**:

- `components/auth/SignInModal.js` or `app/auth/page.js`
- Email input field
- "Send Magic Link" button
- Alternative "Send Code" option
- Loading states
- Error handling

**Flow**:

1. User enters email
2. Click "Send Magic Link"
3. Show confirmation: "Check your email for a magic link"
4. User clicks link in email
5. Redirect to app, user is signed in

#### 1.2 Session Management

**Client-Side**:

- Store session token in secure cookie (HTTP-only, SameSite)
- Check session on app load
- Redirect to sign in if session expired
- Show user email/avatar in header when signed in

**Components**:

- `components/auth/UserMenu.js` - Dropdown with user info and sign out
- `components/auth/SessionProvider.js` - Context provider for session state

### 2. Settings Page

#### 2.1 Settings UI

**Route**: `app/settings/page.js`

**Sections**:

1. **Account**: Email, sign out
2. **Sports**: Select preferred sports
3. **Favorite Spots**: Manage favorite spots
4. **Display Preferences**: All display settings
5. **Custom Prompts**: Create/edit prompts for sports and spots
6. **Spot Requests**: View submitted requests

**Components**:

- `components/settings/SettingsPage.js`
- `components/settings/SportsSection.js`
- `components/settings/FavoritesSection.js`
- `components/settings/DisplaySection.js`
- `components/settings/PromptsSection.js`
- `components/settings/SpotRequestsSection.js`

### 3. Integration with Existing Features

#### 3.1 Sport Selector

**Update**: `components/layout/SportSelector.js`

- If user is authenticated, load preferred sports from user preferences
- Allow temporary selection (stored in session state)
- Option to "Save as default" (updates user preferences)

#### 3.2 Spot Display

**Update**: `components/forecast/DaySection.js` or spot list

- Show favorite indicator (star/heart icon)
- Allow marking spots as favorite
- Filter to show only favorites (optional toggle)

#### 3.3 Scoring Integration

**Update**: Scoring system (from PRD 02)

- When scoring: Check for user prompts first
- Fall back to system prompts if no user prompt exists
- Use user's preferred sports for default scoring

---

## Email Service Integration

### Email Provider Options

1. **Resend**: Simple API, good developer experience
2. **SendGrid**: Robust, feature-rich
3. **Convex Email**: If Convex provides email integration
4. **AWS SES**: Cost-effective for high volume

### Email Templates

#### 1. Magic Link Email

**Subject**: "Sign in to Waterman"

**Body**:

```
Hi,

Click the link below to sign in to Waterman:

[Sign In Link]

This link expires in 15 minutes.

If you didn't request this, you can safely ignore this email.
```

#### 2. Code Email

**Subject**: "Your Waterman sign-in code"

**Body**:

```
Hi,

Your sign-in code is: [CODE]

Enter this code to sign in. It expires in 15 minutes.

If you didn't request this, you can safely ignore this email.
```

#### 3. Spot Request Confirmation

**Subject**: "Spot request received"

**Body**:

```
Hi,

We've received your request to add [Spot Name] to Waterman.

We'll review your request and get back to you soon.

Request details:
- Spot: [Spot Name]
- Location: [Location]
- Sports: [Sports]

Thanks for helping improve Waterman!
```

---

## Security Considerations

### 1. Token Security

- **Cryptographic Strength**: Use cryptographically secure random tokens (32+ bytes)
- **Expiration**: Tokens expire after 15 minutes
- **Single-Use**: Tokens can only be used once
- **Rate Limiting**: Limit token generation per email (prevent abuse)

### 2. Session Security

- **HTTP-Only Cookies**: Prevent XSS attacks
- **SameSite**: Prevent CSRF attacks
- **Secure Flag**: Use HTTPS only
- **Expiration**: Sessions expire after 30 days of inactivity

### 3. Email Verification

- **Email Format Validation**: Validate email format before sending
- **Domain Validation**: Optional - validate email domain
- **Rate Limiting**: Limit sign-in requests per IP/email

### 4. Data Privacy

- **User Data**: Only store necessary user data
- **GDPR Compliance**: Allow users to delete their account and data
- **Email Privacy**: Don't share email addresses

---

## Migration Strategy

### Phase 1: Authentication Foundation

1. **Database Schema**:
   - Add `users`, `authTokens`, `userSessions` tables
   - Add `userPreferences`, `userFavoriteSpots` tables
   - Add `spotRequests` table
   - Update `scoring_prompts` table (add `userId` field)

2. **Authentication Backend**:
   - Implement `auth.requestSignIn` action
   - Implement `auth.verifyToken` action
   - Implement `auth.createSession` mutation
   - Implement `auth.getCurrentUser` query
   - Implement `auth.signOut` mutation

3. **Email Service**:
   - Set up email service (Resend, SendGrid, etc.)
   - Create email templates
   - Test email delivery

4. **Frontend Auth**:
   - Create sign-in modal/page
   - Implement session management
   - Add user menu to header

### Phase 2: User Preferences

1. **Preferences Backend**:
   - Implement `users.getPreferences` query
   - Implement `users.updatePreferences` mutation

2. **Settings UI**:
   - Create settings page
   - Implement sports configuration
   - Implement display preferences
   - Integrate with existing sport selector

### Phase 3: Favorite Spots

1. **Favorites Backend**:
   - Implement `users.getFavoriteSpots` query
   - Implement `users.addFavoriteSpot` mutation
   - Implement `users.removeFavoriteSpot` mutation

2. **Favorites UI**:
   - Add favorite indicator to spots
   - Add favorites section in settings
   - Optional: Filter to show only favorites

### Phase 4: Custom Prompts

1. **Prompts Backend**:
   - Implement `prompts.getUserPrompt` query
   - Implement `prompts.saveUserPrompt` mutation
   - Implement `prompts.deleteUserPrompt` mutation
   - Update scoring system to use user prompts (from PRD 02)

2. **Prompts UI**:
   - Create prompts editor in settings
   - Allow creating prompts for sports
   - Allow creating prompts for spot-sport combinations

### Phase 5: Spot Requests

1. **Requests Backend**:
   - Implement `spots.requestSpot` mutation
   - Implement `spots.getUserSpotRequests` query

2. **Requests UI**:
   - Add "Request Spot" button
   - Create spot request form
   - Show request status in settings

---

## Testing Requirements

### Authentication

- Test magic link flow (email → click link → signed in)
- Test code flow (email → enter code → signed in)
- Test token expiration (expired token rejected)
- Test single-use tokens (token can't be used twice)
- Test session expiration (expired session requires re-authentication)
- Test sign out (session cleared)

### User Preferences

- Test saving preferences (sports, display settings)
- Test loading preferences on app start
- Test preference sync across devices
- Test default values when no preferences set

### Favorite Spots

- Test adding favorite spot
- Test removing favorite spot
- Test favorite spots appear in list
- Test preventing duplicate favorites

### Custom Prompts

- Test creating sport prompt
- Test creating spot-sport prompt
- Test prompt priority (user prompt overrides system prompt)
- Test deleting prompt (falls back to system prompt)
- Test scoring uses user prompts (integration with PRD 02)

### Spot Requests

- Test submitting spot request
- Test viewing request status
- Test email confirmation sent

---

## Success Criteria

### V1 Success Metrics

- ✅ Users can sign in with email magic link
- ✅ Users can configure preferred sports
- ✅ Users can mark spots as favorites
- ✅ Users can configure display preferences
- ✅ Preferences persist across sessions and devices
- ✅ Users can create custom scoring prompts
- ✅ Users can request new spots
- ✅ Anonymous users can still use app (backward compatible)

### User Experience

- ✅ Sign-in flow is simple and intuitive
- ✅ Settings page is easy to navigate
- ✅ Preferences apply immediately
- ✅ No disruption to existing anonymous users

---

## Risks & Mitigations

### Risk 1: Email Delivery Issues

- **Impact**: High - Users can't sign in if emails don't deliver
- **Mitigation**:
  - Use reliable email service (Resend, SendGrid)
  - Monitor email delivery rates
  - Provide fallback code method
  - Add email to spam whitelist instructions

### Risk 2: Token/Session Security

- **Impact**: High - Security vulnerability if tokens compromised
- **Mitigation**:
  - Use cryptographically secure tokens
  - Implement proper expiration
  - Use HTTP-only cookies for sessions
  - Rate limit token generation

### Risk 3: User Data Migration

- **Impact**: Medium - Existing users may lose preferences
- **Mitigation**:
  - Maintain localStorage fallback for anonymous users
  - Provide migration path (optional account creation)
  - Don't force authentication (anonymous mode still works)

### Risk 4: Email Service Costs

- **Impact**: Low - Email service may have costs
- **Mitigation**:
  - Use cost-effective provider (Resend free tier: 3,000 emails/month)
  - Monitor email usage
  - Implement rate limiting to prevent abuse

---

## Dependencies

- Email service account (Resend, SendGrid, etc.)
- Convex authentication support (if available)
- Frontend cookie management library (if needed)
- Existing scoring system (from PRD 02) for custom prompts integration

---

## Open Questions

1. **Email Service**: Which provider to use?
   - **Decision**: Start with Resend (simple, good free tier)

2. **Session Storage**: Cookies vs localStorage?
   - **Decision**: HTTP-only cookies for security (requires server-side session management)

3. **Anonymous Mode**: Should anonymous users be prompted to sign in?
   - **Decision**: No prompts initially, optional "Sign in to sync preferences" button

4. **Custom Prompts UI**: How complex should the prompt editor be?
   - **Decision**: Start with simple text area, can enhance later with templates

5. **Spot Request Admin**: When to build admin interface?
   - **Decision**: V1 allows requests, admin interface in future PRD

---

## References

- PRD 01: Additional Features (sport selection, spots, display)
- PRD 02: LLM-Based Condition Scoring System (custom prompts integration)
- Architecture Document: `/planning/architecture.md`
- Convex Authentication Documentation (if available)
- Email Service Documentation (Resend, SendGrid, etc.)

---

**Document Maintained By**: Engineering Team  
**Last Updated**: 2025-12-28
