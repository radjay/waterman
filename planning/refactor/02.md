# Waterman Code Refactoring Plan - Phase 2

**Date**: December 2025  
**Status**: ðŸ“‹ Planning  
**Focus**: Code reuse, component patterns, and logic extraction

## Overview

This document outlines a comprehensive refactoring plan focused on:
1. **Code Reuse**: Eliminating duplication in components and functions
2. **Logic Extraction**: Moving complex logic into reusable utilities
3. **Component Patterns**: Creating reusable component patterns
4. **Code Organization**: Improving maintainability and testability

---

## 1. Direction Range Checking Logic

### Problem
Direction range checking logic (with wrap-around support) is duplicated in multiple places:
- `app/page.js` (lines 94-106 for wingfoil wind direction)
- `app/page.js` (lines 122-132 for surfing wave direction)
- `scripts/debug_filter.mjs` (lines 38-42)

### Solution
**Extract to utility function**: `lib/utils.js`

```javascript
/**
 * Check if a direction (in degrees 0-360) falls within a range.
 * Handles wrap-around cases (e.g., 315Â° â†’ 135Â° crosses 0Â°).
 * 
 * @param {number} direction - Direction to check (0-360)
 * @param {number} from - Range start (0-360)
 * @param {number} to - Range end (0-360)
 * @returns {boolean} True if direction is within range
 */
export function isDirectionInRange(direction, from, to) {
  if (from === undefined || to === undefined) {
    return true; // No direction filter
  }
  
  if (from <= to) {
    // Normal range (e.g., 90-180)
    return direction >= from && direction <= to;
  } else {
    // Wrap-around range (e.g., 315-135 crosses 0Â°)
    return direction >= from || direction <= to;
  }
}
```

### Refactoring Steps
1. Add function to `lib/utils.js`
2. Replace all instances in `app/page.js` (2 locations)
3. Replace instance in `scripts/debug_filter.mjs`
4. Test with edge cases (0Â°, 360Â°, wrap-around ranges)

### Files Affected
- `lib/utils.js` (add function)
- `app/page.js` (replace 2 instances)
- `scripts/debug_filter.mjs` (replace 1 instance)

---

## 2. Tide Time Formatting

### Problem
Tide time formatting logic is duplicated:
- `components/forecast/DaySection.js` (lines 120-125)
- `components/tide/TideSection.js` (lines 11-14)
- `app/api/calendar/[sport]/route.js` (line 84)

### Solution
**Extract to utility function**: `lib/utils.js`

```javascript
/**
 * Format a timestamp as HH:MM time string.
 * 
 * @param {number|Date} timestamp - Timestamp (ms) or Date object
 * @returns {string} Formatted time string (e.g., "14:30")
 */
export function formatTideTime(timestamp) {
  const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
  const hours = date.getHours().toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  return `${hours}:${minutes}`;
}
```

### Refactoring Steps
1. Add function to `lib/utils.js`
2. Replace in `components/forecast/DaySection.js`
3. Replace in `components/tide/TideSection.js`
4. Replace in `app/api/calendar/[sport]/route.js`

### Files Affected
- `lib/utils.js` (add function)
- `components/forecast/DaySection.js` (replace)
- `components/tide/TideSection.js` (replace)
- `app/api/calendar/[sport]/route.js` (replace)

---

## 3. Date Formatting Duplication

### Problem
1. `formatTime` is duplicated in `app/api/calendar/[sport]/route.js` (lines 25-32) even though it exists in `lib/utils.js`
2. Complex date formatting logic in `app/page.js` (lines 304-355) for day formatting

### Solution
**Use existing utility**: Import `formatTime` from `lib/utils.js` in calendar route

**Extract day formatting**: Create utility function for full day formatting

```javascript
/**
 * Format a date as a full day string (e.g., "Monday, January 1").
 * 
 * @param {number|Date} timestamp - Timestamp (ms) or Date object
 * @returns {string} Formatted day string
 */
export function formatFullDay(timestamp) {
  const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
  return date.toLocaleDateString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric",
  });
}
```

### Refactoring Steps
1. Add `formatFullDay` to `lib/utils.js`
2. Update `app/api/calendar/[sport]/route.js` to import `formatTime` from utils
3. Replace complex logic in `app/page.js` (lines 304-355) with `formatFullDay`
4. Remove duplicate `formatTime` from calendar route

### Files Affected
- `lib/utils.js` (add function)
- `app/api/calendar/[sport]/route.js` (remove duplicate, add import)
- `app/page.js` (simplify day formatting)

---

## 4. Sport-Specific Criteria Matching Logic

### Problem
The criteria matching logic in `app/page.js` (lines 85-156) is very long and mixes wingfoil and surfing logic. This makes it hard to maintain and test.

### Solution
**Extract to separate utility functions**: `lib/criteria.js`

Create a new file with sport-specific matching functions:

```javascript
/**
 * Check if a slot matches wingfoiling criteria.
 * 
 * @param {Object} slot - Forecast slot
 * @param {Object} config - Spot configuration for wingfoiling
 * @returns {boolean} True if slot matches criteria
 */
export function matchesWingfoilCriteria(slot, config) {
  const isSpeed = slot.speed >= (config.minSpeed || 0);
  const isGust = slot.gust >= (config.minGust || 0);
  const isDir = isDirectionInRange(
    slot.direction,
    config.directionFrom,
    config.directionTo
  );
  
  return isSpeed && isGust && isDir;
}

/**
 * Check if a slot matches surfing criteria.
 * 
 * @param {Object} slot - Forecast slot
 * @param {Object} config - Spot configuration for surfing
 * @returns {{matches: boolean, isIdealDirection: boolean}} Match result
 */
export function matchesSurfingCriteria(slot, config) {
  const hasSwell = slot.waveHeight >= (config.minSwellHeight || 0);
  const maxSwell = config.maxSwellHeight 
    ? slot.waveHeight <= config.maxSwellHeight 
    : true;
  const hasPeriod = slot.wavePeriod >= (config.minPeriod || 0);
  
  // Direction check (for ideal marking, not filtering)
  const isIdealDirection = isDirectionInRange(
    slot.waveDirection,
    config.swellDirectionFrom,
    config.swellDirectionTo
  );
  
  // Tide check
  let isTide = true;
  if (config.optimalTide && slot.tideType) {
    if (config.optimalTide === "high") {
      isTide = slot.tideType === "high";
    } else if (config.optimalTide === "low") {
      isTide = slot.tideType === "low";
    }
    // "both" means any tide is fine
  }
  
  return {
    matches: hasSwell && maxSwell && hasPeriod && isTide,
    isIdealDirection
  };
}
```

### Refactoring Steps
1. Create `lib/criteria.js` with matching functions
2. Update `app/page.js` to use these functions
3. Simplify the enrichment logic in `app/page.js`

### Files Affected
- `lib/criteria.js` (new file)
- `app/page.js` (refactor enrichment logic)

---

## 5. Ideal Slot Calculation Logic

### Problem
The logic for finding ideal slots (lines 238-276 in `app/page.js`) has duplicated logic for surfing vs wingfoil.

### Solution
**Extract to utility function**: `lib/criteria.js`

```javascript
/**
 * Find the ideal slot from a list of matching slots.
 * 
 * @param {Array} matchingSlots - Slots that match criteria
 * @param {string} sport - Sport type ("wingfoil" or "surfing")
 * @returns {Object|null} Ideal slot or null
 */
export function findIdealSlot(matchingSlots, sport) {
  if (matchingSlots.length === 0) return null;
  
  if (sport === "surfing") {
    // For surfing: prioritize slots with ideal direction, then best wave quality
    const idealDirectionSlots = matchingSlots.filter(
      s => s.isIdealDirection === true
    );
    const candidates = idealDirectionSlots.length > 0 
      ? idealDirectionSlots 
      : matchingSlots;
    
    // Find best wave (height * period as quality metric)
    const bestWave = Math.max(
      ...candidates.map(s => (s.waveHeight || 0) * (s.wavePeriod || 0))
    );
    return candidates.find(
      s => (s.waveHeight || 0) * (s.wavePeriod || 0) === bestWave
    );
  } else {
    // For wingfoil: find max speed slot
    const maxSpeed = Math.max(...matchingSlots.map(s => s.speed || 0));
    return matchingSlots.find(s => s.speed === maxSpeed);
  }
}
```

### Refactoring Steps
1. Add function to `lib/criteria.js`
2. Replace logic in `app/page.js` (lines 255-269)
3. Simplify the ideal slot marking code

### Files Affected
- `lib/criteria.js` (add function)
- `app/page.js` (simplify ideal slot logic)

---

## 6. Tide Finding Logic

### Problem
The `findTideForSlot` function in `DaySection.js` (lines 50-92) is complex and could be extracted for reuse and testing.

### Solution
**Extract to utility function**: `lib/tides.js`

```javascript
/**
 * Find the closest tide for a forecast slot timestamp.
 * 
 * @param {number} slotTimestamp - Forecast slot timestamp
 * @param {number|null} nextSlotTimestamp - Next slot timestamp (for range)
 * @param {Array} spotTides - Array of tide objects with {time, type, height}
 * @param {Set} usedTides - Set of already-used tide timestamps
 * @returns {Object|null} Tide object or null
 */
export function findTideForSlot(slotTimestamp, nextSlotTimestamp, spotTides, usedTides) {
  if (!spotTides || spotTides.length === 0) return null;
  
  let bestTide = null;
  let bestDiff = Infinity;
  
  spotTides.forEach(tide => {
    // Skip if already used
    if (usedTides.has(tide.time)) return;
    
    const tideTime = tide.time;
    
    // Check if tide is between current and next slot
    if (nextSlotTimestamp && tideTime >= slotTimestamp && tideTime < nextSlotTimestamp) {
      const diff = tideTime - slotTimestamp;
      if (diff < bestDiff) {
        bestDiff = diff;
        bestTide = tide;
      }
    }
    // Check if tide is before current slot (within 3 hours)
    else if (tideTime < slotTimestamp) {
      const diff = slotTimestamp - tideTime;
      if (diff <= 3 * 60 * 60 * 1000 && diff < bestDiff) {
        bestDiff = diff;
        bestTide = tide;
      }
    }
  });
  
  if (bestTide) {
    usedTides.add(bestTide.time);
    return {
      ...bestTide,
      type: bestTide.type || (bestTide.height > 2 ? 'high' : 'low')
    };
  }
  
  return null;
}
```

### Refactoring Steps
1. Create `lib/tides.js` with tide utility functions
2. Move `findTideForSlot` to `lib/tides.js`
3. Update `DaySection.js` to import and use the function

### Files Affected
- `lib/tides.js` (new file)
- `components/forecast/DaySection.js` (use imported function)

---

## 7. Reusable Select Component Pattern

### Problem
`SportSelector` and `ShowFilter` components have nearly identical structure:
- Both use localStorage with hydration pattern
- Both have similar select dropdown UI
- Both have similar state management logic

### Solution
**Create reusable `Select` component**: `components/ui/Select.js`

```javascript
"use client";

import { useState, useEffect } from "react";

/**
 * Reusable select component with localStorage persistence.
 * 
 * @param {Array} options - Array of {id, label} objects
 * @param {string} value - Current selected value
 * @param {Function} onChange - Callback when value changes
 * @param {string} storageKey - localStorage key for persistence
 * @param {string} defaultValue - Default value if nothing in storage
 * @param {string} className - Additional CSS classes
 */
export function Select({ 
  options, 
  value, 
  onChange, 
  storageKey, 
  defaultValue,
  className = "" 
}) {
  const [selectedValue, setSelectedValue] = useState(defaultValue);
  const [isHydrated, setIsHydrated] = useState(false);

  // Load from localStorage after hydration
  useEffect(() => {
    setIsHydrated(true);
    if (storageKey) {
      const stored = localStorage.getItem(storageKey);
      if (stored && options.some(opt => opt.id === stored)) {
        setSelectedValue(stored);
        if (onChange) onChange(stored);
        return;
      }
    }
    // Notify parent of default on first load
    if (onChange) {
      onChange(defaultValue);
    }
  }, []);

  useEffect(() => {
    // Save to localStorage whenever selection changes (but only after hydration)
    if (isHydrated && storageKey) {
      localStorage.setItem(storageKey, selectedValue);
      if (onChange) {
        onChange(selectedValue);
      }
    }
  }, [selectedValue, isHydrated, storageKey, onChange]);

  const handleChange = (newValue) => {
    setSelectedValue(newValue);
  };

  return (
    <div className={className}>
      <div className="relative inline-block">
        <select
          value={value || selectedValue}
          onChange={(e) => handleChange(e.target.value)}
          className="px-3 pr-8 py-1 rounded border border-ink/30 bg-newsprint text-ink font-body font-medium text-xs uppercase cursor-pointer focus:outline-none focus:border-ink hover:bg-ink/5 appearance-none"
        >
          {options.map((option) => (
            <option key={option.id} value={option.id}>
              {option.label}
            </option>
          ))}
        </select>
        <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-ink">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
    </div>
  );
}
```

Then refactor `SportSelector` and `ShowFilter` to use this component:

```javascript
// SportSelector.js
import { Select } from "../ui/Select";

const SPORTS = [
  { id: "wingfoil", label: "Wing" },
  { id: "surfing", label: "Surf" },
];

export function SportSelector({ onSportsChange, className = "" }) {
  const handleChange = (sportId) => {
    if (onSportsChange) {
      onSportsChange([sportId]);
    }
  };

  return (
    <Select
      options={SPORTS}
      onChange={handleChange}
      storageKey="waterman_selected_sport"
      defaultValue="wingfoil"
      className={className}
    />
  );
}
```

### Refactoring Steps
1. Create `components/ui/Select.js`
2. Refactor `SportSelector` to use `Select`
3. Refactor `ShowFilter` to use `Select`
4. Test localStorage persistence

### Files Affected
- `components/ui/Select.js` (new file)
- `components/layout/SportSelector.js` (refactor)
- `components/layout/ShowFilter.js` (refactor)

---

## 8. Data Group Component Pattern

### Problem
`WindGroup` and `WaveGroup` have very similar structure:
- Both use `Metric` component
- Both use `DirectionIndicator`
- Both have similar layout

### Solution
**Create reusable `DataGroup` component**: `components/ui/DataGroup.js`

```javascript
import { Metric } from "./Metric";
import { DirectionIndicator } from "../forecast/DirectionIndicator";

/**
 * Reusable data group component for displaying metrics with direction.
 * 
 * @param {ReactNode} icon - Icon component
 * @param {ReactNode} children - Metric value/content
 * @param {number} direction - Direction in degrees (optional)
 * @param {boolean} showDirection - Whether to show direction indicator
 * @param {string} className - Additional CSS classes
 */
export function DataGroup({ icon, children, direction, showDirection = true, className = "" }) {
  return (
    <div className={`flex items-center justify-start gap-6 ${className}`}>
      <Metric icon={icon}>
        {children}
      </Metric>
      {showDirection && direction !== undefined && (
        <DirectionIndicator direction={direction} />
      )}
    </div>
  );
}
```

Then refactor `WindGroup` and `WaveGroup`:

```javascript
// WindGroup.js
import { Wind } from "lucide-react";
import { DataGroup } from "../ui/DataGroup";

export function WindGroup({ speed, gust, direction, showGust = true, className = "" }) {
  return (
    <DataGroup
      icon={<Wind size={14} className="mr-2" />}
      direction={direction}
      className={className}
    >
      {Math.round(speed)} kn {showGust && <span>({Math.round(gust)}*)</span>}
    </DataGroup>
  );
}
```

### Refactoring Steps
1. Create `components/ui/DataGroup.js`
2. Refactor `WindGroup` to use `DataGroup`
3. Refactor `WaveGroup` to use `DataGroup`
4. Handle edge case where direction might be undefined

### Files Affected
- `components/ui/DataGroup.js` (new file)
- `components/forecast/WindGroup.js` (refactor)
- `components/forecast/WaveGroup.js` (refactor)

---

## 9. Tide Display Component Duplication

### Problem
Tide display logic is duplicated in `ForecastSlot.js`:
- Desktop version (lines 50-63)
- Mobile version (lines 99-112)
- Both have identical logic for displaying tide icons and text

### Solution
**Extract to reusable component**: `components/tide/TideDisplay.js`

```javascript
import { WavesArrowDown, WavesArrowUp } from "lucide-react";
import { formatTideTime } from "../../lib/utils";

/**
 * Display tide information with icon and formatted time.
 * 
 * @param {Object} tide - Tide object with {type, time, height}
 * @param {string} className - Additional CSS classes
 */
export function TideDisplay({ tide, className = "" }) {
  if (!tide) return null;
  
  const type = tide.type?.toLowerCase();
  const timeStr = tide.timeStr || formatTideTime(tide.time);
  const heightStr = tide.height !== null && tide.height !== undefined 
    ? `(${tide.height.toFixed(1)}m)` 
    : '';
  
  return (
    <div className={`flex items-center gap-2 text-sm text-ink ${className}`}>
      {type === 'high' ? (
        <WavesArrowUp size={16} className="text-ink flex-shrink-0" strokeWidth={2} />
      ) : type === 'low' ? (
        <WavesArrowDown size={16} className="text-ink flex-shrink-0" strokeWidth={2} />
      ) : (
        <span className="text-ink">â€¢</span>
      )}
      <span className="font-body whitespace-nowrap">
        {timeStr} {heightStr}
      </span>
    </div>
  );
}
```

### Refactoring Steps
1. Create `components/tide/TideDisplay.js`
2. Update `ForecastSlot.js` to use `TideDisplay` in both desktop and mobile versions
3. Remove duplicated tide display code

### Files Affected
- `components/tide/TideDisplay.js` (new file)
- `components/forecast/ForecastSlot.js` (refactor both versions)

---

## 10. Epic Conditions Detection

### Problem
Epic conditions detection is hardcoded in `app/page.js` (line 72) and could be extracted for reuse and easier configuration.

### Solution
**Extract to utility function**: `lib/criteria.js`

```javascript
/**
 * Check if a slot represents "epic" conditions.
 * Epic = high wind speed (â‰¥20 knots) with steady wind (gust - speed â‰¤ 10 knots).
 * 
 * @param {Object} slot - Forecast slot
 * @returns {boolean} True if slot is epic
 */
export function isEpicConditions(slot) {
  return slot.speed >= 20 && (slot.gust - slot.speed) <= 10;
}
```

### Refactoring Steps
1. Add function to `lib/criteria.js`
2. Replace hardcoded check in `app/page.js`
3. Consider making thresholds configurable in the future

### Files Affected
- `lib/criteria.js` (add function)
- `app/page.js` (replace hardcoded check)

---

## 11. Tide-Only Slot Detection

### Problem
Tide-only slot detection logic in `app/page.js` (lines 75-79) is complex and could be extracted.

### Solution
**Extract to utility function**: `lib/tides.js`

```javascript
/**
 * Check if a slot is a tide-only entry (has tide data but no meaningful wind/wave data).
 * 
 * @param {Object} slot - Forecast slot
 * @returns {boolean} True if slot is tide-only
 */
export function isTideOnlySlot(slot) {
  return slot.isTideOnly || (
    slot.tideTime && 
    slot.tideType && 
    (slot.speed === 0 || !slot.speed) && 
    (slot.gust === 0 || !slot.gust) &&
    (slot.waveHeight === 0 || !slot.waveHeight)
  );
}
```

### Refactoring Steps
1. Add function to `lib/tides.js`
2. Replace logic in `app/page.js`
3. Update any other places that check for tide-only slots

### Files Affected
- `lib/tides.js` (add function)
- `app/page.js` (replace detection logic)

---

## 12. Missing Calendar API Function

### Problem
`app/api/calendar/[sport]/route.js` references `api.calendar.getIdealSlots` which doesn't exist in the codebase. This will cause runtime errors.

### Solution
**Create the missing Convex function**: `convex/calendar.ts`

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { api } from "./_generated/api";

/**
 * Query to get ideal forecast slots for calendar feed.
 * Returns slots that match criteria and are marked as ideal.
 * 
 * @param {Array<string>} sports - Sports to filter by
 * @returns {Array} Array of ideal slots with spot information
 */
export const getIdealSlots = query({
  args: {
    sports: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    // Get spots for selected sports
    const spots = await ctx.runQuery(api.spots.list, {
      sports: args.sports,
    });
    
    const idealSlots = [];
    
    // For each spot, get forecast slots and configs
    for (const spot of spots) {
      const slots = await ctx.runQuery(api.spots.getForecastSlots, {
        spotId: spot._id,
      });
      
      // Get configs for each sport
      const spotSports = spot.sports || [];
      const relevantSports = spotSports.filter(s => args.sports.includes(s));
      
      const configPromises = relevantSports.map(sport =>
        ctx.runQuery(api.spots.getSpotConfig, {
          spotId: spot._id,
          sport: sport,
        })
      );
      
      const configs = await Promise.all(configPromises);
      
      // Enrich slots and find ideal ones
      // (Similar logic to app/page.js but simplified for calendar)
      // This would need to use the criteria matching functions from lib/criteria.js
      // Note: Convex functions can't import from lib/, so we'd need to duplicate
      // the matching logic or move it to a shared location
    }
    
    return idealSlots;
  },
});
```

**Alternative Solution**: Since Convex functions can't easily share logic with client code, consider:
1. Moving the ideal slot calculation to the client side
2. Creating a simpler query that returns all matching slots, then filter on client
3. Or duplicate the matching logic in Convex (not ideal but pragmatic)

### Refactoring Steps
1. Decide on approach (client-side vs server-side filtering)
2. Implement the calendar query function
3. Test calendar endpoint
4. Update documentation

### Files Affected
- `convex/calendar.ts` (new file or update existing)
- `app/api/calendar/[sport]/route.js` (verify it works)

---

## 13. Slot Enrichment Logic Extraction

### Problem
The slot enrichment logic in `app/page.js` (lines 68-171) is very long and mixes multiple concerns:
- Date/time formatting
- Epic detection
- Tide-only detection
- Criteria matching
- Sport matching

### Solution
**Extract to utility function**: `lib/slots.js`

```javascript
import { formatTime } from "./utils";
import { isEpicConditions } from "./criteria";
import { isTideOnlySlot } from "./tides";
import { matchesWingfoilCriteria, matchesSurfingCriteria } from "./criteria";

/**
 * Enrich forecast slots with formatted data and criteria matching.
 * 
 * @param {Array} slots - Raw forecast slots from database
 * @param {Object} spot - Spot object
 * @param {Array} configs - Array of spot configs (one per sport)
 * @returns {Array} Enriched slots with matching criteria, sport, etc.
 */
export function enrichSlots(slots, spot, configs) {
  return slots.map((slot) => {
    const date = new Date(slot.timestamp);
    const hourStr = formatTime(date);
    const isEpic = isEpicConditions(slot);
    const isTideOnly = isTideOnlySlot(slot);
    
    // Check if slot matches criteria
    let matchesCriteria = false;
    let matchedSport = null;
    
    if (!isTideOnly) {
      for (const config of configs) {
        if (!config) continue;
        
        if (config.sport === "wingfoil") {
          if (matchesWingfoilCriteria(slot, config)) {
            matchesCriteria = true;
            matchedSport = "wingfoil";
            break;
          }
        } else if (config.sport === "surfing") {
          const result = matchesSurfingCriteria(slot, config);
          if (result.matches) {
            matchesCriteria = true;
            matchedSport = "surfing";
            slot.isIdealDirection = result.isIdealDirection;
            break;
          }
        }
      }
    }
    
    return {
      ...slot,
      spotName: spot.name,
      spotId: spot._id,
      hour: hourStr,
      isEpic,
      sport: matchedSport,
      isTideOnly,
      matchesCriteria: matchesCriteria || isTideOnly,
    };
  });
}
```

### Refactoring Steps
1. Create `lib/slots.js`
2. Move enrichment logic from `app/page.js`
3. Update `app/page.js` to use the function
4. Test that all enrichment still works correctly

### Files Affected
- `lib/slots.js` (new file)
- `app/page.js` (simplify, use enrichment function)

---

## 14. Date Filtering and Sorting Logic

### Problem
Date filtering and sorting logic in `app/page.js` (lines 215-236) could be extracted for clarity.

### Solution
**Extract to utility function**: `lib/slots.js`

```javascript
/**
 * Filter and sort days, removing past dates.
 * 
 * @param {Object} grouped - Object mapping day strings to spot data
 * @returns {Array} Sorted array of day strings (today and future only)
 */
export function filterAndSortDays(grouped) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  return Object.keys(grouped)
    .filter((day) => {
      const firstSlot = grouped[day][Object.keys(grouped[day])[0]]?.[0];
      if (!firstSlot) return false;
      
      const slotDate = new Date(firstSlot.timestamp);
      slotDate.setHours(0, 0, 0, 0);
      
      return slotDate >= today;
    })
    .sort((a, b) => {
      const firstSlotA = grouped[a][Object.keys(grouped[a])[0]]?.[0];
      const firstSlotB = grouped[b][Object.keys(grouped[b])[0]]?.[0];
      if (!firstSlotA || !firstSlotB) return 0;
      return firstSlotA.timestamp - firstSlotB.timestamp;
    });
}
```

### Refactoring Steps
1. Add function to `lib/slots.js`
2. Replace logic in `app/page.js`
3. Test date filtering still works

### Files Affected
- `lib/slots.js` (add function)
- `app/page.js` (simplify)

---

## 15. Tide Collection Logic

### Problem
Tide collection logic in `DaySection.js` (lines 95-130) is complex and could be extracted.

### Solution
**Extract to utility function**: `lib/tides.js`

```javascript
/**
 * Collect and format tides from forecast slots.
 * 
 * @param {Object} spotsData - Object mapping spotId to array of slots
 * @returns {Object} Object mapping spotId to {spotName, tides} objects
 */
export function collectTidesBySpot(spotsData) {
  const tidesBySpot = {};
  
  Object.keys(spotsData).forEach(spotId => {
    if (spotId === '_tides') return;
    
    const spotSlots = spotsData[spotId];
    const spotTides = spotSlots
      .filter(s => s.tideTime && s.tideType)
      .map(s => ({
        time: s.tideTime,
        type: s.tideType,
        height: s.tideHeight,
      }))
      .filter((tide, index, self) => 
        index === self.findIndex(t => t.time === tide.time)
      );
    
    if (spotTides.length > 0) {
      const spotName = spotSlots.find(s => s.spotName)?.spotName 
        || spotSlots[0]?.spotName 
        || "Unknown Spot";
      
      tidesBySpot[spotId] = {
        spotName,
        tides: spotTides.map(tide => {
          const date = new Date(tide.time);
          return {
            ...tide,
            timeStr: formatTideTime(date)
          };
        }).sort((a, b) => a.time - b.time)
      };
    }
  });
  
  return tidesBySpot;
}
```

### Refactoring Steps
1. Add function to `lib/tides.js`
2. Replace logic in `DaySection.js`
3. Test tide collection still works

### Files Affected
- `lib/tides.js` (add function)
- `components/forecast/DaySection.js` (simplify)

---

## Summary of New Files

### New Utility Files
1. `lib/criteria.js` - Criteria matching functions
2. `lib/tides.js` - Tide-related utility functions
3. `lib/slots.js` - Slot enrichment and processing functions

### New Component Files
1. `components/ui/Select.js` - Reusable select component
2. `components/ui/DataGroup.js` - Reusable data group component
3. `components/tide/TideDisplay.js` - Reusable tide display component

### New Convex Files
1. `convex/calendar.ts` - Calendar query function (if needed)

---

## Refactoring Priority

### High Priority (Core Functionality)
1. **Direction Range Checking** (#1) - Used in multiple places
2. **Criteria Matching Logic** (#4) - Core business logic
3. **Missing Calendar API** (#12) - Bug fix
4. **Slot Enrichment** (#13) - Major simplification

### Medium Priority (Code Quality)
5. **Tide Time Formatting** (#2) - Reduces duplication
6. **Date Formatting** (#3) - Reduces duplication
7. **Ideal Slot Calculation** (#5) - Improves maintainability
8. **Tide Finding Logic** (#6) - Improves testability

### Lower Priority (Polish)
9. **Reusable Select Component** (#7) - Nice to have
10. **Data Group Component** (#8) - Nice to have
11. **Tide Display Component** (#9) - Reduces duplication
12. **Epic Conditions** (#10) - Small improvement
13. **Tide-Only Detection** (#11) - Small improvement
14. **Date Filtering** (#14) - Small improvement
15. **Tide Collection** (#15) - Small improvement

---

## Testing Strategy

After each refactoring:
1. **Manual Testing**: Test the affected features in the UI
2. **Edge Cases**: Test with edge cases (0Â°, 360Â°, wrap-around ranges, missing data)
3. **Regression Testing**: Ensure existing functionality still works
4. **Code Review**: Verify code is cleaner and more maintainable

---

## Implementation Order

### Phase 1: Core Utilities (Week 1)
1. Create `lib/criteria.js` with direction range checking
2. Create `lib/tides.js` with tide utilities
3. Create `lib/slots.js` with slot enrichment
4. Fix calendar API function

### Phase 2: Component Refactoring (Week 2)
5. Create reusable UI components (`Select`, `DataGroup`, `TideDisplay`)
6. Refactor components to use new utilities and components

### Phase 3: Main Page Simplification (Week 3)
7. Refactor `app/page.js` to use extracted utilities
8. Simplify and clean up the main page component

---

## Benefits

### Code Quality
- âœ… Reduced duplication (DRY principle)
- âœ… Better separation of concerns
- âœ… More testable code (utilities can be unit tested)
- âœ… Easier to maintain and extend

### Developer Experience
- âœ… Easier to find and understand code
- âœ… Reusable components reduce future work
- âœ… Clearer component responsibilities
- âœ… Better code organization

### Performance
- âœ… No performance impact (same logic, better organized)
- âœ… Potential for future optimizations (e.g., memoization)

---

## Notes

- All refactoring should maintain existing functionality
- No breaking changes to API or component interfaces
- Consider adding TypeScript types in future refactoring
- Document new utility functions with JSDoc comments

---

**Document Maintained By**: Engineering Team  
**Last Updated**: December 2025


